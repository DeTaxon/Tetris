
PlayField := class extend GUIObject
{
	width := int
	height := int

	//baseMesh := TVkMesh^

	//tilesPool := TDescriptorPool^
	//tileTexture := TVkTexture^
	//tileDesc := VkDescriptorSet

	base := TetrisWindow^
	baseIndCount := int

	boxSize := int
	margin := int

	FieldState := bool[1024]

	sEng := SoundEngine^
	ToastySound := Sound^

	IsInRange := !(int x, int y) -> bool
	{
		if x < 0 or y < 0
			return false
		if x >= width or y >= height
			return false
		return true
	}
	IsSpot := !(int x, int y) -> bool
	{
		if not IsInRange(x,y)
			return false
		return Spot(x,y)
	}
	Spot := !(int x, int y) -> ref bool
	{
		indx := x + y*width
		return FieldState[indx]
	}

	SetField := !(int w, int h) -> void
	{
		width = w
		height = h

		boxSize = 15
		margin = 2

		SetSize("static",boxSize*w + margin*(w - 1), "static", boxSize*h + margin*(h - 1))

		vecData := Vector.{float}
		vecData.Resize(5*4)

		for itX,i : ![0.0,1.0,1.0,0.0] , itY : ![0.0,0.0,1.0,1.0]
		{
			vecData[i*5] = itX*boxSize
			vecData[i*5 + 1] = itY*boxSize
			vecData[i*5 + 2] = itX
			vecData[i*5 + 3] = itY
			colorData := vecData[i*5 + 4]&->{u8^}
			colorData[0] = 255
			colorData[1] = 255
			colorData[2] = 255
			colorData[3] = 255
		}

		indData := Vector.{s32}
		indData.Resize(6)
		indData[0] = 0
		indData[1] = 1
		indData[2] = 2
		indData[3] = 0
		indData[4] = 2
		indData[5] = 3
		baseIndCount = 6
	}

	shaderId := u32

	InitGL := virtual !(WindowGLContext^ ctx) -> bool
	{
		ptr := char^
		len := int
		shaderId = ctx.gl.CreateProgram()

		vert := ctx.gl.CreateShader(GL_VERTEX_SHADER)
		fFile := #File("local:PlayFieldGLVertex.vert").GetBlob()
		ptr = fFile.GetPointer()->{char^}
		len = fFile.Size()
		ctx.gl.ShaderSource(vert,1,ptr&,len&)
		ctx.gl.CompileShader(vert)

		ctx.gl.GetShaderiv(vert,GL_INFO_LOG_LENGTH,len&)

		if len > 1
		{
			blb := MakeBlob(len)
			ctx.gl.GetShaderInfoLog(vert,len,null,blb.GetPointer()->{char^})
			printf("failed to compile vertex shader %s\n",blb.GetPointer())
			return false
		}

		frag := ctx.gl.CreateShader(GL_FRAGMENT_SHADER)
		vFile := #File("local:PlayFieldGLFragment.frag").GetBlob()
		ptr = vFile.GetPointer()->{char^}
		len = vFile.Size()
		ctx.gl.ShaderSource(frag,1,ptr&,len&)
		ctx.gl.CompileShader(frag)

		ctx.gl.GetShaderiv(frag,GL_INFO_LOG_LENGTH,len&)

		if len > 1
		{
			blb := MakeBlob(len)
			ctx.gl.GetShaderInfoLog(frag,len,null,blb.GetPointer()->{char^})
			printf("failed to compile fragment shader %s\n",blb.GetPointer())
			return false
		}

		ctx.gl.AttachShader(shaderId,frag)
		ctx.gl.AttachShader(shaderId,vert)
		ctx.gl.LinkProgram(shaderId)

		status := int
		ctx.gl.GetProgramiv(shaderId, GL_LINK_STATUS, status&)

		ctx.gl.GenVertexArrays(1,vao&)
		ctx.gl.GenBuffers(1,vbo&)

		ctx.gl.BindVertexArray(vao)
		ctx.gl.BindBuffer(GL_ARRAY_BUFFER,vbo)

		ctx.gl.EnableVertexAttribArray(0)
		ctx.gl.VertexAttribPointer(0,2,GL_FLOAT,GL_FALSE,6*4,null)

		dat := u64
		dat = 8
		ctx.gl.EnableVertexAttribArray(1)
		ctx.gl.VertexAttribPointer(1,4,GL_FLOAT,GL_FALSE,6*4,dat&->{void^^}^)

		ctx.gl.GenBuffers(1,vboIndex&)
		ctx.gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER,vboIndex)
		return true
		
	}

	vao := u32
	vbo := u32
	vboIndex := u32
	DrawGL := virtual !(WindowGLContext^ ctx, vec2f offset) -> void
	{
		vecs := Vector.{float}
		vecs.Resize(width*height*6*4)
		vecPtr := vecs.GetPointer()


		shapeIndx := bool[1024]
		PerBoxCheck(CurrentShapePos,CurrentShapeRotation,(x,y) ==> {
			shapeIndx[y*width + x] = true
		})

		for x : width
		{
			for y : height
			{
				vecInd := (y*width + x)*6*4
				spt := IsSpot(x,y) or shapeIndx[y*width + x]


				for z : 4 , offsetX : ![false,true,false,true], offsetY : ![false,false,true,true] 
				{
					vecThisPtr := vecPtr[vecInd + z*6]&

					vecThisPtr[0] = x*(boxSize + margin)
					if offsetX
						vecThisPtr[0] += boxSize
					vecThisPtr[1] = y*(boxSize + margin)
					if offsetY
						vecThisPtr[1] += boxSize

					vecThisPtr[0] += offset.x
					vecThisPtr[1] += offset.y

					vecThisPtr[0] = vecThisPtr[0] / 400.0
					vecThisPtr[1] = vecThisPtr[1] / 470.0

					vecThisPtr[0] = vecThisPtr[0]*2 - 1.0
					vecThisPtr[1] = 1.0 - vecThisPtr[1]*2
					
					colorPtr := vecThisPtr[2]&

					if spt {
						colorPtr[0] = 1.0 
						colorPtr[1] = 1.0 
						colorPtr[2] = 1.0 
						colorPtr[3] = 1.0 
					}else{
						colorPtr[0] = 0.0 
						colorPtr[1] = 0.0 
						colorPtr[2] = 0.0 
						colorPtr[3] = 1.0
					}

				}
			}
		}

		inds := Vector.{int}
		inds.Resize(width*height*6)
		indsPtr := inds.GetPointer()

		for x : width
		{
			for y : height
			{
				off := (y*width + x)*4
				thisPtr := indsPtr[(y*width + x)*6]&
				thisPtr[0] = off + 0
				thisPtr[1] = off + 1
				thisPtr[2] = off + 2
				thisPtr[3] = off + 1
				thisPtr[4] = off + 3
				thisPtr[5] = off + 2
			}
		}

		ctx.gl.BindVertexArray(vao)

		ctx.gl.UseProgram(shaderId)
		ctx.gl.BindVertexArray(vao)
		ctx.gl.BindBuffer(GL_ARRAY_BUFFER,vbo)
		ctx.gl.BufferData(GL_ARRAY_BUFFER,vecs.Size()*4,vecs.GetPointer(),GL_DYNAMIC_DRAW)
		ctx.gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER,vboIndex)
		ctx.gl.BufferData(GL_ELEMENT_ARRAY_BUFFER,4*inds.Size(),inds.GetPointer(),GL_DYNAMIC_DRAW)
		ctx.gl.DrawElements(GL_TRIANGLES,width*height*6,GL_UNSIGNED_INT,null)

		//for x : width
		//{
		//	for y : height
		//	{
		//		DrawGLTile(ctx,vec4f(0.5,0.5,0.5,1.0),offset,x,y)

		//		if not Spot(x,y)
		//			continue

		//		DrawGLTile(ctx,vec4f(1.0,1.0,1.0,1.0),offset,x,y)
		//	}
		//}
		//DrawGLShape(ctx,offset)
	}



	mnstrInUse := bool
	mnstrTime := double
	mnstrPos := vec2f
	mnstrInverse := bool
	mnstrMove := double

	Step := !(double delta) -> void
	{
		mnstrMove = 120
		if mnstrInUse
		{
			times := ![0.2,1.0,0.2]
			addedTimes := ![0.0,0.0,0.0]

			acc := 0.0
			for d : times , ad : addedTimes
			{
				acc += d
				ad = acc
			}
			
			if mnstrTime < addedTimes[0]
			{
				proc := mnstrTime / times[0]
				mnstrPos = vec2f(mnstrMove,0.0)*(proc)
			}else if mnstrTime < addedTimes[1] {
				SpawnGlider()
			}else if mnstrTime < addedTimes[2] {
				proc := (mnstrTime - addedTimes[1]) / times[2]
				proc = 1.0 - proc
				mnstrPos = vec2f(mnstrMove,0.0)*proc
			} else{
				mnstrInUse = false
				mnstrInverse = not mnstrInverse
			}
			mnstrTime += delta
		}
	}
	StartMonster := !() -> void
	{
		if gliderExist
			return void
		sEng.PlaySound(ToastySound)
		mnstrInUse = true
		mnstrTime = 0
	}

	gliderExist := bool
	gliderPosition := vec2i
	gliderAnimation := int
	gliderInverse := bool

	SpawnGlider := !() -> void
	{
		if gliderExist
			return void

		gliderExist = true
		gliderInverse = mnstrInverse
		gliderAnimation = 0
		if mnstrInverse
		{
			gliderPosition = vec2i(12,2)
		}else{
			gliderPosition = vec2i(-5,2)
		}
	}
	GliderStep := !() -> void
	{
		if not gliderExist
			return void

		if gliderInverse
		{
			gliderPosition.x -= ShiftX[gliderAnimation] 
		}else{
			gliderPosition.x += ShiftX[gliderAnimation] 
		}
		gliderPosition.y += ShiftY[gliderAnimation]
		gliderAnimation = (gliderAnimation + 1) mod 4

		if gliderInverse and gliderPosition.x < 0
		{
			gliderExist = false
		}else if not gliderInverse and gliderPosition.x >7 {
			gliderExist = false
		}else{
			for i : 9
			{
				pos := GetGliderPos(i)
				if IsSpot(pos?.x,pos?.y)
					gliderExist = false
			}
		}
		if not gliderExist
		{
			for i : 9
			{
				pos := GetGliderPos(i)
				if not pos.IsSet()
					continue
				if IsInRange(pos.x,pos.y)
				{
					Spot(pos.x,pos.y) = true
				}
			}
		}
	}
	GetGliderPos := !(int indx) -> vec2i?
	{
		x := indx mod 3
		y := indx div 3
		stripe := y*3 + gliderAnimation*9
		checkX := x
		if gliderInverse
			checkX = 2 - x
		if Glider[stripe + checkX] != 1
			return void
		result = vec2i(gliderPosition.x + x,gliderPosition.y + y)
	}

	//secretTexture := TVkTexture^ 
	//secretDescr := VkDescriptorSet
}

GlobInfo := class
{
	offset := vec2f
	boxSize := vec2f
	boxMargin := vec2f
	counts := vec2i
};
